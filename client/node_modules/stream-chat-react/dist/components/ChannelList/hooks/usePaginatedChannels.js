import { __assign, __awaiter, __generator, __spreadArray } from "tslib";
import { useEffect, useMemo, useState } from 'react';
import { MAX_QUERY_CHANNELS_LIMIT } from '../utils';
import { useChatContext } from '../../../context/ChatContext';
export var usePaginatedChannels = function (client, filters, sort, options, activeChannelHandler) {
    var _a = useChatContext('usePaginatedChannels').channelsQueryState, setError = _a.setError, setQueryInProgress = _a.setQueryInProgress;
    var _b = useState([]), channels = _b[0], setChannels = _b[1];
    var _c = useState(true), hasNextPage = _c[0], setHasNextPage = _c[1];
    // memoize props
    var filterString = useMemo(function () { return JSON.stringify(filters); }, [filters]);
    var sortString = useMemo(function () { return JSON.stringify(sort); }, [sort]);
    var queryChannels = function (queryType) { return __awaiter(void 0, void 0, void 0, function () {
        var offset, newOptions, channelQueryResponse, newChannels, err_1;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    setError(null);
                    if (queryType === 'reload') {
                        setChannels([]);
                        setQueryInProgress('reload');
                    }
                    else {
                        setQueryInProgress('load-more');
                    }
                    offset = queryType === 'reload' ? 0 : channels.length;
                    newOptions = __assign({ limit: (_a = options === null || options === void 0 ? void 0 : options.limit) !== null && _a !== void 0 ? _a : MAX_QUERY_CHANNELS_LIMIT, offset: offset }, options);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client.queryChannels(filters, sort || {}, newOptions)];
                case 2:
                    channelQueryResponse = _b.sent();
                    newChannels = queryType === 'reload' ? channelQueryResponse : __spreadArray(__spreadArray([], channels, true), channelQueryResponse, true);
                    setChannels(newChannels);
                    setHasNextPage(channelQueryResponse.length >= newOptions.limit);
                    // Set active channel only on load of first page
                    if (!offset && activeChannelHandler) {
                        activeChannelHandler(newChannels, setChannels);
                    }
                    return [3 /*break*/, 4];
                case 3:
                    err_1 = _b.sent();
                    console.warn(err_1);
                    setError(err_1);
                    return [3 /*break*/, 4];
                case 4:
                    setQueryInProgress(null);
                    return [2 /*return*/];
            }
        });
    }); };
    var loadNextPage = function () {
        queryChannels();
    };
    useEffect(function () {
        queryChannels('reload');
    }, [filterString, sortString]);
    return {
        channels: channels,
        hasNextPage: hasNextPage,
        loadNextPage: loadNextPage,
        setChannels: setChannels,
    };
};
